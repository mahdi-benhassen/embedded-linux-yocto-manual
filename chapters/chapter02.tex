\chapter{Development Environment Setup}

\section{Host Requirements}
Embedded development requires a powerful Linux host.
\begin{itemize}
    \item \textbf{OS}: Ubuntu 20.04 or 22.04 LTS (64-bit).
    \item \textbf{RAM}: 16GB minimum (32GB recommended for Yocto).
    \item \textbf{Storage}: 100GB+ SSD (Builds are massive).
\end{itemize}

\section{Docker: The Modern Way}
Instead of installing dependencies directly on your host (and breaking them when you upgrade Ubuntu), use Docker containers. This ensures every developer on your team uses the \emph{exact} same environment.

\subsection{Setting up a Yocto Container}
1. Install Docker on your host.
2. Run a container with the required dependencies (e.g., CROPS):
\begin{lstlisting}[language=bash]
docker run --rm -it -v $(pwd):/workdir crops/poky:ubuntu-22.04
\end{lstlisting}

\section{Connectivity Tools}
You need to talk to the board.

\subsection{Serial Console (UART)}
The lifeline of embedded debugging.
\begin{itemize}
    \item \textbf{picocom}: Simple, no-nonsense.
    \begin{lstlisting}[language=bash]
picocom -b 115200 /dev/ttyUSB0
    \end{lstlisting}
    \item \textbf{screen}: The classic. To exit: \texttt{Ctrl+A, K}.
    \item \textbf{Permissions}: Add your user to the \texttt{dialout} group.
    \begin{lstlisting}[language=bash]
sudo usermod -aG dialout $USER
    \end{lstlisting}
\end{itemize}

\subsection{Network Boot Servers}
For rapid kernel/rootfs iteration, avoid flashing SD cards. Boot over the network.

\textbf{TFTP (For Kernel/DTB)}:
\begin{lstlisting}[language=bash]
sudo apt install tftpd-hpa
# Edit /etc/default/tftpd-hpa
TFTP_DIRECTORY="/srv/tftp"
# Restart
sudo systemctl restart tftpd-hpa
\end{lstlisting}

\textbf{NFS (For Rootfs)}:
\begin{lstlisting}[language=bash]
sudo apt install nfs-kernel-server
# Edit /etc/exports
/srv/nfs/rootfs *(rw,sync,no_root_squash,no_subtree_check)
# Restart
sudo systemctl restart nfs-kernel-server
\end{lstlisting}

\section{IDE Setup: VS Code}
Visual Studio Code is excellent for embedded Linux.

\subsection{Remote Development}
1. Install the "Remote - SSH" extension.
2. Connect to your build server (or even the target board if it has SSH!).
3. Edit files directly on the remote machine without syncing.

\subsection{IntelliSense for C/C++}
To get code completion for kernel or application code:
1. Generate a \texttt{compile\_commands.json} (using CMake or BitBake).
2. Point the C/C++ extension to it.
3. Add your toolchain's include paths to \texttt{c\_cpp\_properties.json}.

\section{Version Control (Git)}
\begin{itemize}
    \item \textbf{Atomic Commits}: One feature/fix per commit.
    \item \textbf{Messages}: "Subject line (50 chars)" + "Body (72 chars wrap)".
    \item \textbf{Sign-offs}: Use \texttt{git commit -s} to add `Signed-off-by`. This is mandatory for contributing to the Linux Kernel or Yocto.
\end{itemize}
